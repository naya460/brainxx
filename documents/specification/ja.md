# brainxxとは
brainfuckに大量の命令を追加して、少し実用的にした難解プログラミング言語もどきです。  
読み方は「ブレインエックス」です。  
現在、仕様のバージョンは0.5です。  

# プログラムの構成
プログラムはASCIIコードで書かれたテキストファイルです。  
UTF-8などの互換性のある文字コードに対応している必要はありません。  

プログラムは0個以上の、命令(operation)またはコメントで構成されます。  

## コメント
命令以外の文字は全てコメントとして扱われ、コンパイラに無視されます。  
そのため、スペースや改行などの文字も無視されます。  
但し、NULL文字などの制御文字は使用できない場合があります。  

## 命令
各命令は独立しており、コンパイラは、先読みを行ったり、結合順を意識する必要はありません。  
つまり、先頭から順番に読むだけでコンパイルすることが出来ます。  

抽象的な例：  
```
AA と AB 、CA という命令のみがあった場合：
  AAAB は、AA と AB という命令が並んでいます。
  AAB は、AA という命令の後に、Bというコメントが並んでいます。
  CAAA は、CA と AA という命令が並んでいます。
```

### 分類
命令は1個以上の文字で構成されます。文字は、以下の3種類に分けられます。  
- 非終端文字  
    次の文字も同じ命令の構成文字であることを示します。  
    この文字で命令が終わることはありません。  

- 終端文字  
    この文字が命令の終わりであることを示します。  

- 正の整数  
    0から9が1個以上並び、10進数で示されます。  
    それ以外の文字が出現したら判定を終わります。  

    0と01が同じである、数値(`__num__`)として扱われる場合と、  
    0と01が異なる、数字の文字列(`__num_str__`)として扱われる場合があります。  
    これは、命令によって異なります。  

抽象的な例：
```
AA と CA という命令のみがあった場合：
  CAA は、CA という命令の後に、不正な命令Aがあります。
  前から順番に処理されるため、コメントCと命令AAに分割されることはありません。
```

### 注意点
非終端文字や終端文字は命令によって異なります。  

抽象的な例：
```
AA と AB という命令のみがあった場合：
  1文字目のAは、非終端文字として扱われます。
  1文字目のAの後には、AまたはBが終端文字となり、どちらかが必要です。
  1文字目がBの場合、コメントとなります。もちろん、BBやBCもコメントとなります。
```

命令の途中(非終端文字の後)の文字はコメントとして扱われません。  
そのため、命令の途中にコメントを挿入することはできません。  
文字列が命令として成立していない場合、不正な命令としてコンパイルエラー(または実行の中止)となります。  

抽象的な例：
```
AA という命令のみがあった場合：
  ABA は、不正です。(Aの後には、Aがあるはずです。)
```

# プログラムの動作
## メモリ
プログラムは、十分な長さを持ったメモリ上で実行されます。  
メモリ上の1つの値は、符号有り整数で8bit以上(32bit以上推奨)です。  
  
現在操作するメモリ位置(current pointer、以降cptr)があります。  
現在のcptrの指す値や、現在のメモリ位置自体を動かすことによって、プログラムが動作します。  
cptrを1増やすとは、次の値(スタックの伸びる方向)に移動するということを意味します。  
  
関数の最初のメモリ位置をbase pointer(以降bptr)と呼びます。  
bptrの位置は利用できるメモリ外であっても良いです。  
そのため、関数の最初では必ずcptrを1増やして作成してください。  

## スタック
cptrの指すメモリは、スタックとして使用することができます。  
スタックのアドレスは正の方向に伸びていきます。  
cptrの指すメモリがスタックの最上位ですが、基本的にその外側も保持します。  
ただし、関数を呼びだしたときには、外側の値は保証されません。  

スタックでは、主に以下の操作が行なわれます。
- pop  
    値を取り出し、cptrを1減らす。  
- push  
    cptrを1増やし、値を入れる。  

# 命令一覧
## スタック
先に取得した値が中置記法の右値として扱います。  

- `+` stack inc  
    cptrが指す値を1増やす  
  
- `-` stack dec  
    cptrが指す値を1減らす  
  
- `$__num__` stack push  
    __num__をpushする。
  
- `$+` stack add  
    値を2つpopし、加算した値をpushする。  
  
- `$-` stack sub  
    値を2つpopし、減算した値をpushする。  
  
- `$*` stack mul  
    値を2つpopし、乗算した値をpushする。  
  
- `$/` stack div  
    値を2つpopし、除算した値をpushする。  
  
- `$%` stack mod  
    値を2つpopし、剰余をpushする。  
  
- `$$` stack dup  
    値を1つpopし、その値を2回pushする。  
  
- `$#` push arg  
    値を1つpopし、取得した値番目の引数をpushする。  
    1が最初の引数です。  

### スタック(比較)
値が条件を満たしているとき1を、満たしていないとき0をpushする。  

- `$<` stack cl  
    値を2つpopし、左値が小さいとき、条件を満たす。  
  
- `$>` stack cg  
    値を2つpopし、左値が大きいとき、条件を満たす。  

- `$==` stack eq  
    値を2つpopし、値が同じとき、条件を満たす。  

- `$=<` stack el  
    値を2つpopし、値が同じか左値が小さいとき、条件を満たす。  

- `$=>` stack eg  
    値を2つpopし、値が同じか左値が大きいとき、条件を満たす。  

- `$=!` stack ne  
    値を2つpopし、値が異なるとき、条件を満たす。  

### スタック(ビット演算)
- `$|` stack or  
    値を2つpopし、論理和をpushする。  

- `$&` stack and  
    値を2つpopし、論理積をpushする。  

- `$^` stack xor  
    値を2つpopし、排他的論理和をpushする。  

- `$~` stack not  
    値を2つpopし、ビット反転した値をpushする。  

- `$[` stack shl  
    値を2つpopし、左値を右値回左論理シフトした値をpushする。  

- `$]` stack shr  
    値を2つpopし、左値を右値回右論理シフトした値をpushする。  

### スタック(ポインタ処理)
スタックの伸びる方向を後、スタックの始点の方向を前とします。  

- `$:^` push cptr  
    現在のcptrをpushする。

- `$:~` push bptr  
    現在のbptrをpushする。

- `$:+` ptr add  
    左辺のポインタから右値個後の値に移動する。

- `$:-` ptr sub  
    左辺のポインタから右値個前の値に移動する。

- `$:>` ptr get  
    値を1つpopし、そのポインタの指す値をpushする。

- `$:<` ptr set
    右辺の値を、左辺のポインタの指す場所にする。

- `$::__num_str__` push tag  
    `tag__num_str__`のポインタをpushする。  

- `$:#__num_str__` push fn  
    `fn__num_str__`のポインタをpushする。  

## タグ
- `::__num_str__` tag def  
    `tag__num_str__`形式のタグを宣言する。

- `:>__num_str__` tag jmp  
    `tag__num_str__`に移動する。

- `:>` tag ptr jmp  
    popした値のメモリに移動する。  

## 関数
- `#:__num_str__` fn def  
    `fn__num_str__`形式の関数を宣言する。  

- `#>__num_str__:__num__` fn call  
    `__num__`個を引数としてpopし、`fn__num_str__関数`を実行する。その後、返り値をpushする。  

- `#>:__num__` fn ptr call  
    最初に実行するポインタをpopする。  
    `__num__`個を引数としてpopし、先にpopしておいたメモリを実行する。その後、返り値をpushする。  

- `#<` fn ret  
    値を1つpopし、それを返り値として関数を抜ける。  

- `#~__num_str__` fn pub  
    fn__num_str__関数を外部に公開する。  

## 操作
メモリの伸びる方向を後、メモリの始点の方向を前とします。  

- `<` ctrl spl  
    cptrを1つ後に移動。  

- `>` ctrl spr  
    cptrを1つ前に移動。  

- `[` ctrl repb  
    cptrの指す値が0のとき、対応する`]`の次の命令に移動する。  

- `]` ctrl repe  
    対応する`[`に移動する。  

- `@` mov cptr  
    値を1つpopし、その値が指す場所にcptrを移動する。  

## 入出力
ascii互換文字とは、asciiコードをそのまま用いることのできる文字コードとします。  
asciiコードやUTF-8などなどが含まれます。  
ascii文字以外は環境依存となります。  

入出力処理は、必ずしも実装する必要はありません。  

- `.` io cout  
    cptrが指す値をascii互換文字として出力する。  

- `,` io cin  
    cptrが指す場所にascii互換文字として入力する。
    入力の終端に達したとき、現在のメモリの位置に、最大値(-1)を書き込む。

# ライセンス  
本ドキュメントは CC BY 4.0 の下で配布されています。  
本ドキュメントは [naya460](https://github.com/naya460) によって書かれました。  
